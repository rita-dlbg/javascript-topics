<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/style.css" rel="stylesheet" type="text/css" />
    <title>Javascript| Learning</title>
</head>
<body>
    <!-- Hoisting  -->
    <div class="center bg-grey pa20">
        <h1>Hoisting In Javascript</h1>
        <p>In Javascript wherever the declarations are there.. It appears at the top of the code before execution.</p>
        <p>Basicly it is the default behaviour to move the declaration on the top of currunt scope. 
            For example the Variable can be declared even after use.</p>
        <mark>Javascript only hoists declarations not initializations. 
            The variable will be undefined untill the line where it is intialized to reach.</mark>   
            <h2>Simple on Top declaration execution</h2>
            <img src="images/2.png" />
            <h3>Even with fucntion declaration at down side of execution code</h3>
            <div><mark>Here the Javascript will execute with default on top declation of fucntion after execution of code
                and output will be the same </mark></div>
            <img src="images/3.png"/>
            <h3>output:</h3>
            <img src="images/1.png"/>
            
         <h1> The let and const Keywords </h1>  
         <p>The let and const is not default hoisted in javascript and will not appear as to the top automatically 
            in javascript.
         </p> 
         <img src="images/4.png" />
         <h3>Error Output:</h3>
         <img src="images/5.png"/>

         <h1> The Var keyword with hoisting </h1>  

         <p>The hoisting with var is works till initialization but not te declared value</p>
         <div><mark>This is the reason the Let and Const is better option as compare to Var</mark></div>
         <img src="images/6.png"/>
         <h3>Outpur normal:</h3>
         <img src="images/7.png"/>

         <p>But the var declartion at the bottom will not appear the error and return as undefined.</p>

         <img src="images/8.png" />
         <h3>Output:</h3>
         <img src="images/9.png"/>

    </div>

    <!-- IIFE -->
    <div class="center bg-blue pa20">
        <h1>IIFE (Immediately Invoked Function Expression)</h1>
        <p>IIFE is usefull when we need to run the syntax for asysc await without any additional function</p>
        <mark>Basicly it is run as soon as it is define in the syntax</mark>
        <p> It is also known as Self-Executing Anonymous Function. The whole syntax holding the two parts:
            <ul class="tl">
                <li>1. The first is the anonymous function with lexical scope enclosed within the Grouping Operator ().
                     This prevents accessing variables within the IIFE idiom as well as polluting the global scope.
                </li>
                <li>
                    2. The second part creates the immediately invoked function expression () 
                    through which the JavaScript engine will directly interpret the function.
                </li>
            </ul>
            <div><mark>When we write the function inside out Grouping Operator then it will be anonymous or we can say
                it will be private function. We cannot access it outside of the fucntion.
            </mark></div>
        </p>
        <h3>Syntax:</h3>
        <code><pre>
            (fucntion(){
                ... 
                ... 
            } ) ();
        </pre>
        </code>
        <p>It avoids the polluting the global namespace and execute async and await.</p>

        <h2>example</h2>
        <h3>Use of IIFE fucntion to keep it private</h3>
        <img src="images/1.1.png"/>
        <p>Also we can can privatly declare the value which will not accessable outside.</p>
        <img src="images/1.2.png"/>
        <h3>Output:</h3>
        <img src="images/1.3.png"/>

        <h1>With async and await</h1>

        <img src="images/1.4.png"/>
        <h3>Output:</h3>
        <img src="images/1.5.png"/>
    </div>

    <!-- Currying -->

    <div class="center bg-grey pa20">
        <h1>Currying In Javascript</h1>
        <p>
            It is a technique in functional programming, transformation of the function of multiple arguments into several functions of a single argument in sequence. 
        </p>
        <div>
            <mark>We simply wrap function inside a function, which means we are going to return a function 
            from another function to obtain this kind of translation. The parent function takes the first
             provided argument and returns the function that takes the next argument and this keeps on 
             repeating till the number of arguments ends. Hopefully, the function that receives the last 
             argument returns the expected result.  
            </mark>

            <H3>In Simple fucntion we are calculating the size</H3>
            <img src="images/2.1.png"/>
            <h4>Output:</h4>
            <img src="images/2.2.png"/>

            <p>In previous exampel we have list of arguments in fucntion which access indivisually and creating a list.
            </p>
            <h3>Same exampel with help of currying</h3>
            <img src="images/2.3.png"/>
            <h4>Output:</h4>
            <img src="images/2.2.png"/>
            <div><mark>To call fucntion in the fucntion and pass the indivisual parameter is called currying in javascript</mark></div>
            <p>
                In the following example we use currying technique with the help of closures where an anonymous function, receiving a parameter and returning some code. 
                When we exposign fucnton from another fucntion, it means it creates the clouser which connect functions
                as a bundle.
                all inner functions will always hold access to the variable of their parent.
            </p>
            <p>As soon as we have got the returned result as a function the next argument is ready to be passed, this process will continue till the second last function. </p>
        </div>

    </div>

    <div class="center bg-blue pa20">
        <h1>Memoization in Javascript</h1>
        <p>It is an optimization technique that can be used to reduce time consuming calcilations by saving 
            previous inut to something called cache and returning the result from it.
        </p>
        <div><mark>Basicly it reduce the time of execution in sort of loop time executions or etc.
            it will store the same code request in cache and save the time of recalling the code or fucntion.
        </mark></div>
        <h3>exampel with simple code</h3>
        <img src="images/3.1.png"/>
        <h4>Output:</h4>
        <img src="images/3.2.png"/>
        <div><mark>Now we will reduce the time of same fucntion with the use of memorization fucntion in javascritp.
            This is used in React as useMemo.
        </mark></div>
        <h3>Example with use of Memoization</h3>
        <img src="images/3.3.png"/>
        <h4>Output:</h4>
        <img src="images/3.4.png"/>
        <p><mark>Memoization is a technique for speeding up applications by caching the results of expensive function calls and returning them when the same inputs are used again.</mark> </p>
        <ul class="tl">
            <li>Expensive Function Calls: Time and memory are the two most important resources in computer 
                applications. As a result, an expensive function call is one that consumes large amounts of these two resources due to extensive calculation during execution.
            </li>
            <li>
                Cache: A cache is just a temporary data store that stores data in order to serve future 
                requests for that data more quickly.
            </li>
        </ul>
    </div>
    <div class="center bg-grey pa20">
        <h1>JavaScript Recursion</h1>
        <p>Recursion is a process of calling itself. A function that calls itself is called a recursive function.</p>

        <h3>Syntax:</h3>
        <code><pre>
            function recurse() {
               ... 
                recurse();
                ... 
            }
            
            recurse();
        </pre>
        </code>
        <div><mark>A recursive function must have a condition to stop calling itself. Otherwise the function is called indefinitely.</mark></div>
        <p>Once the condition is met, the function stops calling itself. </p>
        <div><mark>you use recursive functions to break down a big problem into smaller ones. </mark></div>


    </div>
    <div class="center bg-blue pa20">
        <h1>Pure Functions Javascript</h1>
        <p>pure function is a function that when given the same inputs always returns the same output.
        This function also must have absolutely no side effects and rely on no other state besides the input variables.</p>
    </div>

    <script src="jsfunction/curious.js"></script>
    <!-- <script src="jsfunction/hoisting.js"></script> -->
    <!-- <script src="jsfunction/iife.js"></script> -->
    <!-- <script src="jsfunction/currying.js"></script> -->
    <!-- <script src="jsfunction/memorization.js"></script> -->
    <!-- <script src="jsfunction/recursive.js"></script> -->
    <!-- <script>

        console.log(demovar);

        var demovar = 10;

    </script> -->
</body>
</html>